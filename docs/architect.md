# 架构设计

## 游戏局面

游戏局面可以分为两个玩家的区域，各自有手牌区、支援区、角色区（及后备角色区）、召唤物区和骰子区。

支援区和召唤物区上限分别是 4 和 4。

骰子区上限是 12 （疑似）。

手牌区上限是 16 （疑似）。

角色区最少有一个角色，上限暂定为 6 （玩家上限为 3，NPC 可以更多）。

后备角色区：当角色区全部被击败但后备角色区有角色时，补充到场上。

## 伤害计算

伤害的属性：元素类型、目标、是否穿透、是否无伤害

伤害：各种元素的直接伤害

反应：增幅反应直接增加当次伤害，剧变反应追加一次伤害。

很显然，这里需要一个伤害队列用来方便修改最近未结算的伤害。

边界条件有待测试，先不考虑吧。

## 效果计算

任何发生的变化都可以记为效果，只是我们把伤害单独考虑。

效果通常包括但不限于：
- 切换角色
- 调和骰子
- 消耗骰子
- 使用技能

等等。

每个效果既可以作为触发器，也可以作为触发结果。

（效果也是队列结构？）

## 骰子消耗

显然我们需要一个预计算花费的方法，这个方法能模拟地得到开销而不实际花费骰子。

hook 们就应该挂载到对应字典上，当事件发生时逐个处理 hook，并考虑在事件队列插入新事件。

花费事件先加入事件队列，然后逐个触发 hook 来检定条件与生效。

## 事件预检查

很多物品都是有使用次数限制或者额外触发的，所以如果要做预检，实际上是需要把所有可变状态都抽象出来。

原始状态 =>

预检 -> 检查 hooks -> 检查事件 -> 预检状态 -> 预览 -> 确认操作？

确认 -> 更新原始状态

取消 -> 回到原始状态

所以这里的状态需要统一管理，比如说统一注册到某个变量中来维护。
